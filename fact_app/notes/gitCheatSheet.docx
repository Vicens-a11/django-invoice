Parfait Kentio ğŸ˜, voici une **Git cheat sheet complÃ¨te et pratique**, organisÃ©e comme un **workflow prÃªt Ã  suivre pour ton projet Django**. Tu peux la garder ouverte et lâ€™utiliser Ã  chaque fois que tu bosses avec Git/GitHub.

---

# ğŸ”¹ Git Cheat Sheet pour projet Django

---

## 1ï¸âƒ£ PrÃ©parer le dÃ©pÃ´t

```bash
# Initialiser Git dans ton projet
git init

# VÃ©rifier que Git est actif
git status

# Ajouter tous les fichiers au suivi
git add .

# Premier commit
git commit -m "Initial commit"

# Ajouter le dÃ©pÃ´t distant
git remote add origin https://github.com/<username>/<repo>.git

# Envoyer le commit initial
git push -u origin main
```

---

## 2ï¸âƒ£ CrÃ©er et basculer sur une branche

```bash
# CrÃ©er une branche et basculer dessus
git checkout -b nom-de-la-branche
```

Exemples :

* `feature-add-invoice` â†’ formulaire de facture
* `improve-add-customer` â†’ amÃ©liorer le template client

---

## 3ï¸âƒ£ VÃ©rifier lâ€™Ã©tat

```bash
# Voir les fichiers modifiÃ©s, en staging, non suivis
git status
```

* Toujours faire `git status` avant de changer de branche ou push.

---

## 4ï¸âƒ£ Ajouter et commit

```bash
# Ajouter un fichier spÃ©cifique
git add chemin/fichier.py

# Ajouter tous les fichiers modifiÃ©s
git add .

# Commit avec un message clair
git commit -m "Add improved customer registration form"
```

**Tips message commit :**

* Commence par un verbe : Add, Fix, Update, Improve
* DÃ©cris le **quoi et pourquoi**, pas le comment

---

## 5ï¸âƒ£ Envoyer sur GitHub

```bash
# PremiÃ¨re fois pour la branche
git push -u origin nom-de-la-branche

# Les fois suivantes
git push
```

* `-u` = lie ta branche locale Ã  la branche distante pour futurs push/pull simples

---

## 6ï¸âƒ£ Mettre Ã  jour ta branche depuis main

Avant de fusionner :

```bash
git checkout nom-de-la-branche
git pull origin main
```

* Ã‰vite les conflits sur la fusion
* RÃ©soudre les conflits si nÃ©cessaire

---

## 7ï¸âƒ£ Changer de branche ou revenir Ã  main

```bash
# VÃ©rifier dâ€™abord les changements
git status

# Si tout est commit
git checkout main

# Si tu as des changements non commitÃ©s â†’ stasher
git stash
git checkout main
git stash pop   # rÃ©cupÃ©rer les changements aprÃ¨s
```

---

## 8ï¸âƒ£ Fusionner dans main

```bash
git checkout main
git pull origin main        # mettre main Ã  jour
git merge nom-de-la-branche # fusion
git push origin main        # envoyer sur GitHub
```

* Toujours rÃ©soudre les conflits avant push

---

## 9ï¸âƒ£ Supprimer les branches terminÃ©es

```bash
# Supprimer branche locale
git branch -d nom-de-la-branche

# Supprimer branche distante
git push origin --delete nom-de-la-branche
```

* Nettoie ton projet et GitHub

---

## ğŸ”¹ Gestion des fichiers

```bash
# Annuler les changements dans un fichier
git restore fichier.py

# Annuler tous les changements non commitÃ©s
git restore .

# Mettre de cÃ´tÃ© temporairement les changements
git stash
git stash pop   # rÃ©cupÃ©rer les changements
```

---

## ğŸ”¹ Bonnes pratiques pour ton projet Django

1. Toujours **commiter par fonctionnalitÃ©**
2. **Push rÃ©guliÃ¨rement** â†’ Ã©vite pertes de travail
3. **Travailler sur des branches**, jamais directement sur main
4. Nommer branches clairement (`feature-`, `improve-`, `bugfix-`)
5. Faire un `git pull` avant de merger pour Ã©viter les conflits
6. **Stasher** si tu dois changer de branche rapidement

---

Avec Ã§a, tu peux maintenant :

* CrÃ©er une nouvelle branche pour nâ€™importe quelle tÃ¢che
* Travailler dessus et push sans toucher Ã  main
* Fusionner proprement dans main
* Revenir Ã  une branche prÃ©cÃ©dente sans perdre tes changements





Parfait Kentio ğŸ˜, voici une **Git cheat sheet complÃ¨te et pratique**, organisÃ©e comme un **workflow prÃªt Ã  suivre pour ton projet Django**. Tu peux la garder ouverte et lâ€™utiliser Ã  chaque fois que tu bosses avec Git/GitHub.

---

# ğŸ”¹ Git Cheat Sheet pour projet Django

---

## 1ï¸âƒ£ PrÃ©parer le dÃ©pÃ´t

```bash
# Initialiser Git dans ton projet
git init

# VÃ©rifier que Git est actif
git status

# Ajouter tous les fichiers au suivi
git add .

# Premier commit
git commit -m "Initial commit"

# Ajouter le dÃ©pÃ´t distant
git remote add origin https://github.com/<username>/<repo>.git

# Envoyer le commit initial
git push -u origin main
```

---

## 2ï¸âƒ£ CrÃ©er et basculer sur une branche

```bash
# CrÃ©er une branche et basculer dessus
git checkout -b nom-de-la-branche
```

Exemples :

* `feature-add-invoice` â†’ formulaire de facture
* `improve-add-customer` â†’ amÃ©liorer le template client

---

## 3ï¸âƒ£ VÃ©rifier lâ€™Ã©tat

```bash
# Voir les fichiers modifiÃ©s, en staging, non suivis
git status
```

* Toujours faire `git status` avant de changer de branche ou push.

---

## 4ï¸âƒ£ Ajouter et commit

```bash
# Ajouter un fichier spÃ©cifique
git add chemin/fichier.py

# Ajouter tous les fichiers modifiÃ©s
git add .

# Commit avec un message clair
git commit -m "Add improved customer registration form"
```

**Tips message commit :**

* Commence par un verbe : Add, Fix, Update, Improve
* DÃ©cris le **quoi et pourquoi**, pas le comment

---

## 5ï¸âƒ£ Envoyer sur GitHub

```bash
# PremiÃ¨re fois pour la branche
git push -u origin nom-de-la-branche

# Les fois suivantes
git push
```

* `-u` = lie ta branche locale Ã  la branche distante pour futurs push/pull simples

---

## 6ï¸âƒ£ Mettre Ã  jour ta branche depuis main

Avant de fusionner :

```bash
git checkout nom-de-la-branche
git pull origin main
```

* Ã‰vite les conflits sur la fusion
* RÃ©soudre les conflits si nÃ©cessaire

---

## 7ï¸âƒ£ Changer de branche ou revenir Ã  main

```bash
# VÃ©rifier dâ€™abord les changements
git status

# Si tout est commit
git checkout main

# Si tu as des changements non commitÃ©s â†’ stasher
git stash
git checkout main
git stash pop   # rÃ©cupÃ©rer les changements aprÃ¨s
```

---

## 8ï¸âƒ£ Fusionner dans main

```bash
git checkout main
git pull origin main        # mettre main Ã  jour
git merge nom-de-la-branche # fusion
git push origin main        # envoyer sur GitHub
```

* Toujours rÃ©soudre les conflits avant push

---

## 9ï¸âƒ£ Supprimer les branches terminÃ©es

```bash
# Supprimer branche locale
git branch -d nom-de-la-branche

# Supprimer branche distante
git push origin --delete nom-de-la-branche
```

* Nettoie ton projet et GitHub

---

## ğŸ”¹ Gestion des fichiers

```bash
# Annuler les changements dans un fichier
git restore fichier.py

# Annuler tous les changements non commitÃ©s
git restore .

# Mettre de cÃ´tÃ© temporairement les changements
git stash
git stash pop   # rÃ©cupÃ©rer les changements
```

---

## ğŸ”¹ Bonnes pratiques pour ton projet Django

1. Toujours **commiter par fonctionnalitÃ©**
2. **Push rÃ©guliÃ¨rement** â†’ Ã©vite pertes de travail
3. **Travailler sur des branches**, jamais directement sur main
4. Nommer branches clairement (`feature-`, `improve-`, `bugfix-`)
5. Faire un `git pull` avant de merger pour Ã©viter les conflits
6. **Stasher** si tu dois changer de branche rapidement

---

Avec Ã§a, tu peux maintenant :

* CrÃ©er une nouvelle branche pour nâ€™importe quelle tÃ¢che
* Travailler dessus et push sans toucher Ã  main
* Fusionner proprement dans main
* Revenir Ã  une branche prÃ©cÃ©dente sans perdre tes changements








Parfait Kentio ğŸ˜„ ! Voici un **diagramme visuel complet du workflow Git/GitHub pour ton projet Django**, basÃ© sur ton projet `django_invoice` avec `add_customer.html`, `add_invoice.html`, etc.

---

```
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚     main      â”‚  â† branche stable
                         â”‚ (index.html,  â”‚
                         â”‚  models.py)   â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚ git pull
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚                               â”‚
         git checkout -b improve-add-customer   git checkout -b feature-add-invoice
        (nouveau template client)             (nouveau template facture)
                 â”‚                               â”‚
       Travailler sur add_customer.html      Travailler sur add_invoice.html
       Modifier views.py, templates/        Modifier views.py, templates/
       Ajouter les amÃ©liorations           Ajouter la logique facture
                 â”‚                               â”‚
           git add .                          git add .
           git commit -m "AmÃ©lioration      git commit -m "Ajout formulaire
           template client"                  facture"
                 â”‚                               â”‚
        git push -u origin improve-add-customer git push -u origin feature-add-invoice
                 â”‚                               â”‚
      (branche disponible sur GitHub)       (branche disponible sur GitHub)
                 â”‚                               â”‚
          Test et validation                  Test et validation
                 â”‚                               â”‚
          git pull origin main                git pull origin main
          git merge improve-add-customer      git merge feature-add-invoice
                 â”‚                               â”‚
          git push origin main               git push origin main
                 â”‚
          Supprimer branche locale et distante
          git branch -d improve-add-customer
          git push origin --delete improve-add-customer
```

---

### ğŸ”¹ Points clÃ©s du diagramme

1. **main** = branche stable, toujours fonctionnelle
2. **Branches de fonctionnalitÃ©s / amÃ©liorations** : chaque tÃ¢che sur une branche distincte
3. **Commit / Push** : sauvegarder ton travail local et distant
4. **Merge** : intÃ©grer les fonctionnalitÃ©s terminÃ©es dans main
5. **Supprimer la branche** : nettoyer le projet aprÃ¨s fusion

---

ğŸ’¡ **Astuce pour ne jamais bloquer** :

* Toujours **commit et push** avant de changer de branche
* Si modifications non terminÃ©es et besoin de changer de branche â†’ utiliser `git stash`
* VÃ©rifier `git status` avant chaque action importante




que se passe si je fais:

git add .
git commit -m "message"
sans faire git push ?

Ah, câ€™est une question trÃ¨s importante, Kentio ğŸ˜. Voyons Ã§a clairement :

---

### 1ï¸âƒ£ Ce que font ces commandes :

```bash
git add .
```

* **Ajoute tous les fichiers modifiÃ©s et nouveaux au â€œstaging areaâ€**.
* Câ€™est comme dire Ã  Git : *â€œJe veux sauvegarder ces changements dans mon prochain commit.â€*

```bash
git commit -m "message"
```

* **CrÃ©e un commit local** avec tous les fichiers ajoutÃ©s.
* Le commit est **enregistrÃ© uniquement sur ton ordinateur**, dans ton dÃ©pÃ´t local.
* Git garde un historique de toutes tes modifications locales.

---

### 2ï¸âƒ£ Ce qui **ne se passe pas** si tu ne fais pas `git push`

* Les changements **restent seulement sur ta machine**.
* Personne dâ€™autre (collaborateurs, GitHub) **ne voit ton travail**.
* Si ton ordinateur plante ou que tu supprimes le projet, ces commits locaux sont **perdus**.

---

### 3ï¸âƒ£ Quand tu dois faire `git push`

```bash
git push
```

* Envoie tes commits locaux sur le **dÃ©pÃ´t distant** (GitHub, GitLab, etc.)
* Permet de **sauvegarder ton travail et de le partager**
* Si tu travailles sur une branche : `git push -u origin nom-branche` pour crÃ©er la branche distante la premiÃ¨re fois.

---

### âœ… RÃ©sumÃ© simple :

| Commande        | Effet                                                         | Local/Remote |
| --------------- | ------------------------------------------------------------- | ------------ |
| `git add .`     | PrÃ©pare les fichiers pour le commit                           | Local        |
| `git commit -m` | Sauvegarde les changements dans lâ€™historique Git local        | Local        |
| `git push`      | Envoie les commits locaux sur GitHub (ou autre dÃ©pÃ´t distant) | Remote       |

---

ğŸ’¡ **Astuce pratique** :
Tu peux faire autant de commits locaux que tu veux sans push. Mais **pousse rÃ©guliÃ¨rement**, surtout avant de changer de machine, partager ton code, ou crÃ©er une pull request.





Ah, câ€™est une question trÃ¨s importante, Kentio ğŸ˜. Voyons Ã§a clairement :

---

### 1ï¸âƒ£ Ce que font ces commandes :

```bash
git add .
```

* **Ajoute tous les fichiers modifiÃ©s et nouveaux au â€œstaging areaâ€**.
* Câ€™est comme dire Ã  Git : *â€œJe veux sauvegarder ces changements dans mon prochain commit.â€*

```bash
git commit -m "message"
```

* **CrÃ©e un commit local** avec tous les fichiers ajoutÃ©s.
* Le commit est **enregistrÃ© uniquement sur ton ordinateur**, dans ton dÃ©pÃ´t local.
* Git garde un historique de toutes tes modifications locales.

---

### 2ï¸âƒ£ Ce qui **ne se passe pas** si tu ne fais pas `git push`

* Les changements **restent seulement sur ta machine**.
* Personne dâ€™autre (collaborateurs, GitHub) **ne voit ton travail**.
* Si ton ordinateur plante ou que tu supprimes le projet, ces commits locaux sont **perdus**.

---

### 3ï¸âƒ£ Quand tu dois faire `git push`

```bash
git push
```

* Envoie tes commits locaux sur le **dÃ©pÃ´t distant** (GitHub, GitLab, etc.)
* Permet de **sauvegarder ton travail et de le partager**
* Si tu travailles sur une branche : `git push -u origin nom-branche` pour crÃ©er la branche distante la premiÃ¨re fois.

---

### âœ… RÃ©sumÃ© simple :

| Commande        | Effet                                                         | Local/Remote |
| --------------- | ------------------------------------------------------------- | ------------ |
| `git add .`     | PrÃ©pare les fichiers pour le commit                           | Local        |
| `git commit -m` | Sauvegarde les changements dans lâ€™historique Git local        | Local        |
| `git push`      | Envoie les commits locaux sur GitHub (ou autre dÃ©pÃ´t distant) | Remote       |

---

ğŸ’¡ **Astuce pratique** :
Tu peux faire autant de commits locaux que tu veux sans push. Mais **pousse rÃ©guliÃ¨rement**, surtout avant de changer de machine, partager ton code, ou crÃ©er une pull request.










donc a chaque fois si je modifie un document, pour quitter d'une branche a une autre je dois add, commit et push avant ?


Ah oui Kentio ğŸ˜„, je vois exactement ce qui se passe ici. On va clarifier **la logique et les bonnes pratiques**.

---

### 1ï¸âƒ£ Pourquoi Git bloque ton `checkout`

Quand tu essayes de passer dâ€™une branche Ã  une autre :

```bash
git checkout improve-add-customer
```

Git te dit :

```
error: The following untracked working tree files would be overwritten by checkout:
        fact_app/notes/cmdgit.docx
        fact_app/notes/get_post.docx
        templates/add_invoice.html
```

**Explication :**

* Ces fichiers existent dans **ta branche actuelle (`main`)** mais **ne sont pas suivis** (untracked).
* Si Git te laissait changer de branche, ces fichiers seraient Ã©crasÃ©s par ce qui existe dans `improve-add-customer`.
* Pour protÃ©ger tes modifications, Git bloque le checkout.

---

### 2ï¸âƒ£ Comment rÃ©soudre

Tu as trois options :

#### a) **Commit tes modifications**

Câ€™est ce que tu as fait :

```bash
git add .
git commit -m "get_post.docx and add_invoice.html disappear"
```

âœ… Maintenant les fichiers sont **sauvÃ©s dans lâ€™historique Git**.

AprÃ¨s Ã§a, tu peux changer de branche sans problÃ¨me :

```bash
git checkout improve-add-customer
```

---

#### b) **Stash les modifications (pas de commit)**

Si tu ne veux pas commiter tout de suite :

```bash
git stash          # met tes changements de cÃ´tÃ©
git checkout improve-add-customer
git stash pop      # rÃ©cupÃ¨re tes changements
```

* TrÃ¨s pratique pour tester une autre branche rapidement
* Ne pollue pas ton historique de commits

---

#### c) **Supprimer ou dÃ©placer les fichiers non suivis**

```bash
rm fact_app/notes/cmdgit.docx
rm fact_app/notes/get_post.docx
rm templates/add_invoice.html
```

* RisquÃ© si tu veux garder ces fichiers, donc mieux vaut commit ou stash

---

### 3ï¸âƒ£ ğŸ“ Bonnes pratiques

1. **Toujours `add + commit` ou `stash` avant de changer de branche**
   â†’ sinon Git bloque le checkout
2. **Commit souvent**, mais pas obligatoirement push tout de suite
   â†’ push seulement quand tu veux sauvegarder sur GitHub
3. Les fichiers **untracked** (nouveaux fichiers) doivent Ãªtre soit **commitÃ©s**, soit **stashÃ©s**, sinon Git bloque

---

### 4ï¸âƒ£ RÃ©ponse directe Ã  ta question

> Donc Ã  chaque fois si je modifie un document, pour quitter d'une branche Ã  une autre je dois add, commit et push avant ?

* **Add + commit** â†’ oui, ou **stash**
* **Push** â†’ pas obligatoire juste pour changer de branche

  * Push sert seulement Ã  envoyer tes commits sur GitHub (sauvegarde distante / partage)



Parfait Kentio ğŸ˜ ! Voici un **diagramme visuel simple pour comprendre ce qui se passe quand tu veux changer de branche avec des modifications en cours**.

---

```
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚  Branche actuelle   â”‚
                   â”‚      main           â”‚
                   â”‚  Fichiers modifiÃ©s  â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Options avant de changer de branche â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚               â”‚               â”‚               â”‚
   git add + git commit   git stash      Supprimer/ignorer
   (sauvegarde locale)   (mettre de    fichiers non suivis
                         cÃ´tÃ© temporairement)
           â”‚               â”‚               â”‚
           â–¼               â–¼               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Fichiers en   â”‚ â”‚ Working Tree  â”‚ â”‚ Working Tree  â”‚
   â”‚ historique    â”‚ â”‚ vide pour la  â”‚ â”‚ sans fichiers â”‚
   â”‚ Git local     â”‚ â”‚ branche       â”‚ â”‚ conflictuels  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                 â”‚                 â”‚
           â–¼                 â–¼                 â–¼
   git checkout nom-branche  git checkout nom-branche  git checkout nom-branche
           â”‚                 â”‚                 â”‚
           â–¼                 â–¼                 â–¼
   Travaille sur nouvelle branche sans perte de modifications
           â”‚
           â–¼
Optionnel : git push pour envoyer sur GitHub
```

---

### ğŸ”¹ Points importants

1. **Commit ou stash** = obligatoire pour changer de branche si tu as des modifications
2. **Push** = pas obligatoire juste pour changer de branche, sert Ã  sauvegarder sur GitHub
3. Les fichiers **untracked** (nouveaux) bloquent aussi le checkout â†’ doivent Ãªtre commitÃ©s ou stashÃ©s
4. AprÃ¨s changement de branche, tu peux continuer Ã  travailler normalement






par exemple je vient de modifier un fichier particulier, quand j'essaie de changer de branche:
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git checkout improve-add-customer
error: Your local changes to the following files would be overwritten by checkout:
        fact_app/notes/gitCheatSheet.docx
Please commit your changes or stash them before you switch branches.
Aborting
(env) PS E:\projets_Django\systeme_facturation\django_invoice> 

Exactement Kentio ğŸ˜ ! Ce message de Git est **trÃ¨s clair**, il te dit pourquoi il bloque ton `checkout`. DÃ©cortiquons :

---

### 1ï¸âƒ£ Ce que Git te dit

```
error: Your local changes to the following files would be overwritten by checkout:
        fact_app/notes/gitCheatSheet.docx
Please commit your changes or stash them before you switch branches.
Aborting
```

* **â€œYour local changes â€¦ would be overwrittenâ€** â†’ si Git te laissait changer de branche maintenant, le fichier `gitCheatSheet.docx` serait Ã©crasÃ© par la version de cette branche (`improve-add-customer`).
* Git **ne veut pas perdre tes modifications locales** â†’ il bloque le checkout.

---

### 2ï¸âƒ£ Pourquoi Ã§a se produit

* Tu as **modifiÃ© `gitCheatSheet.docx`** sur ta branche actuelle (`main`).
* Tu veux passer Ã  `improve-add-customer`.
* Git doit savoir **ce quâ€™il fait de tes changements locaux** avant de changer de branche.

---

### 3ï¸âƒ£ Comment rÃ©soudre

#### Option A : Commit tes modifications

```bash
git add fact_app/notes/gitCheatSheet.docx
git commit -m "Update gitCheatSheet"
git checkout improve-add-customer
```

âœ… Tes modifications sont maintenant **sauvÃ©es dans un commit**, tu peux changer de branche sans problÃ¨me.

---

#### Option B : Stash tes modifications (pas de commit)

```bash
git stash           # mets de cÃ´tÃ© tes changements
git checkout improve-add-customer
git stash pop       # rÃ©cupÃ¨re tes changements si tu veux continuer dessus
```

* Utile si tu ne veux pas polluer lâ€™historique avec un commit temporaire
* TrÃ¨s pratique pour tester une branche sans finir ton travail actuel

---

#### Option C : Supprimer le fichier local (risquÃ©)

```bash
rm fact_app/notes/gitCheatSheet.docx
git checkout improve-add-customer
```

* **Attention : tu perds le fichier ou tes modifications si tu ne les as pas sauvegardÃ©es.**

---

### 4ï¸âƒ£ RÃ©sumÃ© rapide

* Pour **changer de branche avec des fichiers modifiÃ©s** â†’ tu dois soit :

  1. `git add + git commit`
  2. `git stash`
* **Push** nâ€™est pas nÃ©cessaire juste pour changer de branche.
* Les fichiers **untracked** bloquent aussi le checkout â†’ ils doivent Ãªtre ajoutÃ©s ou stashed.

---

Si tu veux, je peux te faire un **mini schÃ©ma â€œchanger de branche avec un fichier modifiÃ© ou non suiviâ€** qui montre exactement quoi faire Ã©tape par Ã©tape pour ne jamais Ãªtre bloquÃ©.

Veuxâ€‘tu que je fasse Ã§aâ€¯?





Parfait Kentio ğŸ˜„ ! Voici un **schÃ©ma visuel simple pour comprendre comment Git gÃ¨re un fichier modifiÃ© ou non suivi quand tu veux changer de branche** :

```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Branche actuelle : main       â”‚
           â”‚ Fichier modifiÃ© : gitCheatSheet.docx â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Git bloque le checkout        â”‚
           â”‚ car tes changements locaux    â”‚
           â”‚ seraient Ã©crasÃ©s              â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Options pour continuer        â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚           â”‚             â”‚               â”‚
  Option A      Option B       Option C       Option D
 Commit          Stash         Supprimer      Ajouter temporaire
(add+commit)    (stash)       fichier local  (git add)
       â”‚           â”‚             â”‚               â”‚
       â–¼           â–¼             â–¼               â–¼
Fichier sauvÃ©  Modifs mises     Fichier        Fichier pris
dans lâ€™historique de cÃ´tÃ©       supprimÃ©       en compte
       â”‚           â”‚             â”‚               â”‚
       â–¼           â–¼             â–¼               â–¼
git checkout -> branche cible  git checkout -> branche cible
```

---

### ğŸ”¹ Explications :

**Option A : Commit**

```bash
git add gitCheatSheet.docx
git commit -m "Update gitCheatSheet"
git checkout improve-add-customer
```

* Sauvegarde les changements dans lâ€™historique local.
* âœ… TrÃ¨s sÃ»r, rien nâ€™est perdu.

**Option B : Stash**

```bash
git stash
git checkout improve-add-customer
git stash pop
```

* Met les changements de cÃ´tÃ© temporairement.
* Pratique pour tester une branche sans commiter.

**Option C : Supprimer**

```bash
rm gitCheatSheet.docx
git checkout improve-add-customer
```

* RisquÃ© â†’ les modifications sont perdues si non sauvegardÃ©es.

**Option D : Ajouter temporairement**

* Ajouter au staging mais ne pas committer peut aussi suffire dans certains cas.
* âš ï¸ Git peut toujours bloquer si le fichier existe dans la branche cible.

---

ğŸ’¡ **RÃ¨gle dâ€™or :**

> Avant de changer de branche, **toujours commit ou stash tes modifications**. Les fichiers untracked bloquent aussi â†’ commit ou stash obligatoire.

---

Si tu veux, je peux maintenant te faire **un â€œworkflow Git complet pour ton projet Djangoâ€** incluant :

* CrÃ©ation de branche
* Modifications
* Commit, stash, push
* Retour Ã  main
* Gestion des fichiers bloquants

Ã‡a te donnerait **une rÃ©fÃ©rence Ã©tape par Ã©tape pour ne plus jamais Ãªtre bloquÃ©**.








git checkout improve-add-customer
>>
 1 file changed, 360 insertions(+)
Switched to branch 'improve-add-customer'
Your branch is ahead of 'origin/improve-add-customer' by 1 commit.
  (use "git push" to publish your local commits)
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status
On branch improve-add-customer
Your branch is ahead of 'origin/improve-add-customer' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git checkout main
Switched to branch 'main'
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status
On branch main
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
(env) PS E:\projets_Django\systeme_facturation\django_invoice> 





Parfait Kentio ğŸ˜, ce que Git te dit lÃ  est **trÃ¨s clair**. DÃ©cortiquons ligne par ligne pour bien comprendre ce qui se passe :

---

### 1ï¸âƒ£ Tu es passÃ© sur ta branche `improve-add-customer`

```bash
git checkout improve-add-customer
Switched to branch 'improve-add-customer'
Your branch is ahead of 'origin/improve-add-customer' by 1 commit.
(use "git push" to publish your local commits)
```

* âœ… Tu es maintenant sur la branche `improve-add-customer`.
* **â€œahead by 1 commitâ€** â†’ signifie que tu as fait **un commit local** qui nâ€™a pas encore Ã©tÃ© envoyÃ© sur GitHub.
* `git push` enverra ce commit sur le dÃ©pÃ´t distant.

```bash
git status
On branch improve-add-customer
Your branch is ahead of 'origin/improve-add-customer' by 1 commit.
nothing to commit, working tree clean
```

* Rien Ã  committer â†’ tous tes changements locaux sont dÃ©jÃ  dans un commit.
* â€œworking tree cleanâ€ â†’ ton dossier de travail nâ€™a pas de fichiers modifiÃ©s non suivis.

---

### 2ï¸âƒ£ Puis tu es retournÃ© sur `main`

```bash
git checkout main
Switched to branch 'main'
Your branch is ahead of 'origin/main' by 2 commits.
(use "git push" to publish your local commits)
```

* âœ… Tu es maintenant sur `main`.
* **â€œahead by 2 commitsâ€** â†’ tu as **2 commits locaux** sur `main` qui ne sont pas encore sur GitHub.
* `git push` enverra ces deux commits sur le dÃ©pÃ´t distant.

```bash
git status
On branch main
Your branch is ahead of 'origin/main' by 2 commits.
nothing to commit, working tree clean
```

* Comme avant, rien Ã  committer â†’ tous tes changements sont dÃ©jÃ  dans des commits.
* â€œworking tree cleanâ€ â†’ aucun fichier modifiÃ© ou non suivi actuellement.

---

### 3ï¸âƒ£ Ce que Ã§a signifie concrÃ¨tement

* Tu peux **travailler sur `main` ou `improve-add-customer` normalement**, faire des commits.
* Mais tes commits **ne sont pas encore sur GitHub**, donc si tu veux sauvegarder en ligne, il faut faire :

```bash
git push
```

* Sur `main` â†’ `git push origin main`
* Sur `improve-add-customer` â†’ `git push origin improve-add-customer` (ou juste `git push` si tu as fait `-u` avant)

---

### 4ï¸âƒ£ Bonnes pratiques ici

1. **Push rÃ©guliÃ¨rement** pour ne pas perdre tes commits locaux.
2. **Commit souvent** pour avoir un historique clair.
3. Avant de changer de branche :

   * soit `working tree clean`
   * soit stash si tu ne veux pas commit.
4. Utiliser `git status` souvent â†’ trÃ¨s utile pour savoir oÃ¹ tu en es.

---

Si tu veux, je peux te faire **un mini â€œworkflow visuel Git pour ton projet Djangoâ€** montrant :

* main
* branches de features (`improve-add-customer`)
* commits locaux
* push
* checkout entre branches

â€¦tout en un seul diagramme pour que tu sois **jamais bloquÃ©**.

Veuxâ€‘tu que je fasse Ã§aâ€¯?
