Parfait üòÑ, on va d√©cortiquer **chaque commande Git** que tu as utilis√©e et ce qu‚Äôelle fait exactement.

---

## 1Ô∏è‚É£ `git add .`

* **But** : dire √† Git *¬´ ces fichiers et modifications doivent √™tre pris en compte pour le prochain commit ¬ª*.
* **Le `.`** signifie : *tous les fichiers et dossiers modifi√©s dans le r√©pertoire actuel*.

Exemple pratique :

```bash
git add .
```

* Si tu modifies `views.py` et `add_customer.html`, Git les marque comme **pr√™ts √† √™tre commit√©s**.
* Les fichiers non suivis (`untracked files`) sont √©galement ajout√©s si tu utilises `git add .`.
* Tu peux aussi ajouter **un seul fichier** :

```bash
git add templates/add_customer.html
```

---

## 2Ô∏è‚É£ `git commit -m "quelque chose"`

* **But** : enregistrer un **snapshot (photo)** de ton projet **dans l‚Äôhistorique Git**.
* **`-m "..."`** : c‚Äôest le **message du commit**, qui d√©crit ce que tu as fait.

Exemple :

```bash
git commit -m "Add new customer template"
```

* Git prend **tous les fichiers que tu as ajout√©s avec `git add`** et les enregistre dans un commit.
* Chaque commit a un **identifiant unique** (hash) que tu peux utiliser pour revenir en arri√®re.

üí° Astuce : **messages clairs et courts** = super important pour retrouver facilement ce qui a √©t√© fait.

---

## 3Ô∏è‚É£ `git push`

* **But** : envoyer tes commits locaux vers le **d√©p√¥t distant** (GitHub, GitLab‚Ä¶).
* Ex√©cution typique :

```bash
git push
```

* Git regarde **la branche actuelle**, puis envoie **tous les commits qui n‚Äôont pas encore √©t√© pouss√©s** vers le d√©p√¥t distant.
* Si c‚Äôest la premi√®re fois que tu pousses une nouvelle branche, il faut pr√©ciser :

```bash
git push -u origin ma-branche
```

* `-u origin ma-branche` : cr√©e un lien entre ta branche locale et la branche distante pour les futurs push/pull.

---

### üîπ R√©sum√© rapide

| Commande                  | Ce qu‚Äôelle fait                                               |
| ------------------------- | ------------------------------------------------------------- |
| `git add .`               | Marque tous les fichiers modifi√©s comme pr√™ts pour le commit  |
| `git commit -m "message"` | Enregistre ces fichiers dans l‚Äôhistorique Git avec un message |
| `git push`                | Envoie les commits locaux vers le d√©p√¥t distant (GitHub)      |

---

üí° **Analogie simple** :

* `git add` ‚Üí **mettre tes fichiers dans le panier**
* `git commit` ‚Üí **casser le panier en photo et noter ce qui a √©t√© fait**
* `git push` ‚Üí **envoyer la photo dans un album partag√© en ligne**





Ah super question üòÑ ‚Äî c‚Äôest une subtilit√© importante de Git ! On va la d√©tailler clairement.

---

# 1Ô∏è‚É£ `git push`

```bash
git push
```

* **Fonction** : envoie tes commits **de ta branche locale** vers la **branche distante correspondante** sur le d√©p√¥t (GitHub).
* **Condition** : il doit d√©j√† exister **une branche distante suivie**.
* Si tu es sur `main` et que `main` est d√©j√† li√©e √† `origin/main`, √ßa fonctionne parfaitement.

Exemple :

```bash
# Sur la branche main
git push
```

* Envoie tous les commits locaux sur `main` du d√©p√¥t GitHub.

---

# 2Ô∏è‚É£ `git push -u origin improve-add-customer`

```bash
git push -u origin improve-add-customer
```

* **Fonction** :

  1. Cr√©e la branche `improve-add-customer` sur le d√©p√¥t distant (`origin`) si elle n‚Äôexiste pas encore.
  2. Envoie tes commits **de ta branche locale** vers cette nouvelle branche distante.
  3. **Lie ta branche locale √† la branche distante** (`upstream`) pour que, √† l‚Äôavenir, tu puisses simplement faire `git push` ou `git pull` sans pr√©ciser le nom du d√©p√¥t ou de la branche.

* **Explication du `-u`** : `-u` = `--set-upstream` ‚Üí Git sait que **ta branche locale suit cette branche distante**.

Exemple concret :

```bash
# Premi√®re fois que tu envoies la branche sur GitHub
git push -u origin improve-add-customer
```

Apr√®s √ßa, pour les prochains commits sur cette branche, tu pourras juste faire :

```bash
git push
```

et Git saura automatiquement **vers quelle branche distante envoyer tes commits**.

---

# 3Ô∏è‚É£ Comparaison simple

| Commande                       | Quand l‚Äôutiliser                                                 | Particularit√©                                                                      |
| ------------------------------ | ---------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `git push`                     | Quand la branche locale **est d√©j√† li√©e** √† une branche distante | Envoie les commits sur la branche distante suivie                                  |
| `git push -u origin <branche>` | La **premi√®re fois** qu‚Äôon pousse une branche locale             | Cr√©e la branche distante et lie ta branche locale √† elle pour les futurs push/pull |

---

üí° **Astuce pratique**

* Toujours utiliser `git push -u origin <branche>` **la premi√®re fois** pour une nouvelle branche.
* Ensuite, juste `git push` suffit.






Parfait üòÑ, on va compl√©ter le panorama et te montrer **quand et comment utiliser toutes ces commandes ensemble**.

---

# 1Ô∏è‚É£ `git status`

* **But** : voir l‚Äô√©tat actuel de ton d√©p√¥t Git **local**.
* Montre :

  * Sur quelle **branche** tu es (`main`, `improve-add-customer`, etc.)
  * Quels fichiers sont **modifi√©s mais pas ajout√©s** (`modified`)
  * Quels fichiers sont **ajout√©s pour le prochain commit** (`staged`)
  * Quels fichiers sont **non suivis** (`untracked`)

Exemple :

```bash
git status
```

Sortie typique :

```
On branch main
Changes not staged for commit:
  modified:   views.py
  modified:   index.html

Untracked files:
  add_invoice.html
```

üí° **Quand l‚Äôutiliser** :

* Avant chaque `git add` pour savoir ce qui a chang√©
* Avant un `git commit` pour v√©rifier ce qui va √™tre enregistr√©
* Apr√®s un `git stash` ou `git checkout` pour confirmer o√π tu en es

---

# 2Ô∏è‚É£ `git checkout -b <nom-de-branche>`

* **But** : cr√©er **une nouvelle branche** et **basculer dessus en m√™me temps**.
* Une branche te permet de travailler sur **une fonctionnalit√© ou correction** sans toucher √† la branche principale (`main`).

Exemple :

```bash
git checkout -b improve-add-customer
```

* Cr√©e la branche `improve-add-customer`
* Passe automatiquement sur cette branche
* Tout ce que tu commites ensuite **sera sur cette branche**, pas sur `main`.

üí° **Quand l‚Äôutiliser** :

* Tu veux d√©velopper une nouvelle fonctionnalit√©
* Tu veux am√©liorer un template, un style ou corriger un bug
* Tu veux tester quelque chose sans casser le `main`

---

# 3Ô∏è‚É£ Utilisation pratique de toutes ces commandes ensemble

Imaginons ton workflow typique pour ajouter un nouveau template :

---

### √âtape 1 : V√©rifier l‚Äô√©tat actuel

```bash
git status
```

* Tu vois quels fichiers ont chang√© et si tu es sur `main`.

---

### √âtape 2 : Cr√©er une branche pour travailler

```bash
git checkout -b improve-add-customer
```

* Maintenant tu es sur une branche s√©par√©e, tu peux modifier le template sans toucher √† `main`.

---

### √âtape 3 : Ajouter tes modifications au commit

```bash
git add templates/add_customer.html
```

* Marque le fichier comme pr√™t √† √™tre commit.

---

### √âtape 4 : Enregistrer le commit

```bash
git commit -m "New improved customer registration template"
```

* Git prend un **snapshot** de ton fichier et l‚Äôajoute √† l‚Äôhistorique sur cette branche.

---

### √âtape 5 : V√©rifier que tout est bien

```bash
git status
```

* Tu confirmes qu‚Äôil ne reste rien √† ajouter.

---

### √âtape 6 : Envoyer la branche sur GitHub

```bash
git push -u origin improve-add-customer
```

* La branche est maintenant sur GitHub
* Tu peux partager ou ouvrir une **pull request** plus tard

---

### √âtape 7 : Revenir sur `main` pour continuer autre chose

```bash
git checkout main
```

* Tu es maintenant sur la branche principale, **ind√©pendante de tes modifications de la branche am√©lior√©e**
* Tu peux continuer √† travailler, committer et push comme d‚Äôhabitude.

---

# üîπ R√©sum√© visuel du workflow

```
main (branche stable)
  |
  |-- git checkout -b improve-add-customer
  |    -> travailler sur template
  |    -> git add
  |    -> git commit
  |    -> git push
  |
  |-- git checkout main
       -> continuer √† travailler sur main
```

---

# üîπ Quand utiliser chaque commande

| Commande                    | Quand l‚Äôutiliser                                               |
| --------------------------- | -------------------------------------------------------------- |
| `git status`                | Toujours avant un commit pour savoir ce qui a chang√©           |
| `git add`                   | Quand tu veux pr√©parer un fichier pour commit                  |
| `git commit -m "..."`       | Quand tu veux enregistrer les changements dans l‚Äôhistorique    |
| `git push`                  | Quand tu veux envoyer tes commits vers GitHub                  |
| `git checkout -b <branche>` | Quand tu veux cr√©er une nouvelle branche pour travailler isol√© |
| `git checkout <branche>`    | Quand tu veux basculer entre les branches                      |




PB:
env) PS E:\projets_Django\systeme_facturation\django_invoice> git checkout main 
error: Your local changes to the following files would be overwritten by checkout:
        templates/add_customer.html
Please commit your changes or stash them before you switch branches.
Aborting
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status        
On branch improve-add-customer
Your branch is up to date with 'origin/improve-add-customer'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fact_app/models.py
        modified:   fact_app/urls.py
        modified:   fact_app/views.py
        modified:   templates/add_customer.html
        modified:   templates/index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fact_app/notes/cmdgit.docx
        fact_app/notes/get_post.docx
        templates/add_invoice.html

no changes added to commit (use "git add" and/or "git commit -a")
(env) PS E:\projets_Django\systeme_facturation\django_invoice> 

rps:
Ah oui üëç ‚Äî c‚Äôest exactement ce que Git voulait te dire avec ce message :

> `Your local changes to the following files would be overwritten by checkout`

### En clair :

* Tu es sur la branche `improve-add-customer`.
* Tu as **des fichiers modifi√©s qui ne sont pas commit√©s** (`models.py`, `views.py`, `templates/add_customer.html`‚Ä¶).
* Si tu passes sur `main` maintenant, Git **perdrait tes modifications locales**.
* Donc Git bloque le changement de branche pour **prot√©ger ton travail**.

---

## üîπ 2 fa√ßons de r√©soudre √ßa

### Option 1 : **Commit tes modifications sur la branche actuelle**

1. Ajouter les fichiers au commit :

```bash
git add .
```

2. Commit avec un message clair :

```bash
git commit -m "Work in progress before switching to main"
```

3. Maintenant tu peux passer sur `main` :

```bash
git checkout main
```

---

### Option 2 : **Mettre de c√¥t√© tes modifications avec `stash`**

* Si tu **ne veux pas commit maintenant**, mais juste changer de branche temporairement :

```bash
git stash
```

* Git mettra **tous tes changements locaux de c√¥t√©**.
* Tu peux maintenant changer de branche :

```bash
git checkout main
```

* Pour **r√©cup√©rer tes changements** plus tard sur n‚Äôimporte quelle branche :

```bash
git stash pop
```

üí° Astuce : `stash` est super pratique pour **changer de branche sans perdre ton travail en cours**.

---

### üîπ Que faire dans ton cas

Vu que tu as :

* des fichiers modifi√©s (`models.py`, `views.py`, `add_customer.html`, `index.html`)
* et des fichiers non suivis (`cmdgit.docx`, `get_post.docx`, `add_invoice.html`)

Si tu veux passer sur `main` **tout en gardant ton travail sur `improve-add-customer`**, je te conseille :

1. Stash temporaire :

```bash
git stash
```

2. Passer sur `main` :

```bash
git checkout main
```

3. Quand tu reviens sur `improve-add-customer` :

```bash
git checkout improve-add-customer
git stash pop
```




TLPB:
on\env\Scripts\Activate.ps1
(env) PS E:\projets_Django\systeme_facturation> git add .
fatal: not a git repository (or any of the parent directories): .git
(env) PS E:\projets_Django\systeme_facturation> cd django_invoice
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git add .       
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git commit -m "a[main f536f9b] add new customer
 10 files changed, 698 insertions(+), 29 deletions(-)
 create mode 100644 static/images/icon-yes.svg
 create mode 100644 templates/add_customer.html
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git push        
fatal: unable to access 'https://github.com/Vicens-a11/django-invoice.git/': Could not resolve host: github.com
(env) PS E:\projets_Django\systeme_facturation\django_invoice>


                                                               git push        
Enumerating objects: 28, done.
Counting objects: 100% (28/28), done.
Delta compression using up to 8 threads
Compressing objects: 100% (17/17), done.
Writing objects: 100% (17/17), 7.06 KiB | 1.01 MiB/s, done.
Total 17 (delta 4), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (4/4), completed with 4 local objects.
To https://github.com/Vicens-a11/django-invoice.git
   8a93ec1..f536f9b  main -> main
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status
On branch main
Your branch is up to date with 'origin/main'.

        modified:   fact_app/views.py
        modified:   templates/index.html

  (use "git add <file>..." to include in what will be committed)
        fact_app/notes/get_post.docx
        templates/add_invoice.html

no changes added to commit (use "git add" and/or "git commit -a")
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git checkout -b improve-add-customer
Switched to a new branch 'improve-add-customer'
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git add templates/add_customer.html
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git commit -m "New improved customer registration template"
[improve-add-customer e7376f8] New improved customer registration template       
 1 file changed, 125 insertions(+), 71 deletions(-)
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status        
On branch improve-add-customer
        modified:   fact_app/views.py
        modified:   templates/add_customer.html
        modified:   templates/index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fact_app/notes/get_post.docx
        templates/add_invoice.html

no changes added to commit (use "git add" and/or "git commit -a")
(env) PS E:\projets_Django\systeme_facturation\django_invoice>


                                                               git push -u origin improve-add-customer
Counting objects: 100% (7/7), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 1.20 KiB | 245.00 KiB/s, done.
Total 4 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
remote:
remote: Create a pull request for 'improve-add-customer' on GitHub by visiting:  
remote:      https://github.com/Vicens-a11/django-invoice/pull/new/improve-add-customer
remote:
To https://github.com/Vicens-a11/django-invoice.git
 * [new branch]      improve-add-customer -> improve-add-customer
branch 'improve-add-customer' set up to track 'origin/improve-add-customer'.     
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status        
On branch improve-add-customer
Your branch is up to date with 'origin/improve-add-customer'.

Changes not staged for commit:
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fact_app/models.py
        modified:   fact_app/urls.py
        modified:   fact_app/views.py
        modified:   templates/add_customer.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fact_app/notes/cmdgit.docx
        fact_app/notes/get_post.docx
        templates/add_invoice.html

no changes added to commit (use "git add" and/or "git commit -a")
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git checkout main 
error: Your local changes to the following files would be overwritten by checkout:
        templates/add_customer.html
Please commit your changes or stash them before you switch branches.
Aborting
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status        
On branch improve-add-customer
Your branch is up to date with 'origin/improve-add-customer'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
        modified:   fact_app/models.py
        modified:   fact_app/views.py
        modified:   templates/add_customer.html
        modified:   templates/index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        fact_app/notes/cmdgit.docx
        fact_app/notes/get_post.docx
        templates/add_invoice.html

no changes added to commit (use "git add" and/or "git commit -a")
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git add .
>>
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git commit -m "initial template add_customer"
[improve-add-customer c5373a4] initial template add_customer
 8 files changed, 1817 insertions(+), 130 deletions(-)
 create mode 100644 fact_app/notes/cmdgit.docx
 create mode 100644 fact_app/notes/get_post.docx
 create mode 100644 templates/add_invoice.html
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git checkout main
Switched to branch 'main'
Your branch is up to date with 'origin/main'.
(env) PS E:\projets_Django\systeme_facturation\django_invoice> git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
(env) PS E:\projets_Django\systeme_facturation\django_invoice> 



RPS:

Ok Kentio üòÑ, je vais te r√©sumer **exactement tout ce que tu as fait et ce que Git a fait pour toi** √©tape par √©tape, et pourquoi tu as eu certains messages comme ‚Äúlocal changes would be overwritten‚Äù.

---

## üîπ √âtape par √©tape de ton historique

### 1Ô∏è‚É£ Activation de ton environnement Python

```powershell
on\env\Scripts\Activate.ps1
```

* Tu actives ton environnement virtuel `env`.
* √áa permet √† Python et Django d‚Äôutiliser les bonnes d√©pendances.

---

### 2Ô∏è‚É£ Premier `git add .` dans le mauvais dossier

```powershell
git add .
fatal: not a git repository
```

* Tu √©tais dans `E:\projets_Django\systeme_facturation` qui **n‚Äô√©tait pas encore un d√©p√¥t Git**.
* Git t‚Äôindique qu‚Äôil n‚Äôy a pas de `.git` dans ce dossier.
* ‚úÖ Solution : entrer dans le dossier correct `django_invoice`.

---

### 3Ô∏è‚É£ Entr√©e dans le d√©p√¥t correct

```powershell
cd django_invoice
git add .
git commit -m "a[main f536f9b] add new customer"
```

* Tu ajoutes tous les fichiers modifi√©s/nouveaux au staging (`git add .`)
* Puis tu fais un commit sur `main` avec ton message.
* R√©sultat : **10 fichiers commit√©s** (templates, images, etc.)
* Git enregistre l‚Äô√©tat actuel de ces fichiers sur la branche `main`.

---

### 4Ô∏è‚É£ Push sur GitHub

```powershell
git push
```

* Premi√®re tentative √©choue : `Could not resolve host` ‚Üí probl√®me r√©seau
* Deuxi√®me tentative r√©ussit ‚Üí commits envoy√©s sur `origin/main`
* Tes fichiers sont maintenant sauvegard√©s sur GitHub.

---

### 5Ô∏è‚É£ V√©rification de l‚Äô√©tat

```powershell
git status
```

* Git te montre les fichiers modifi√©s mais **non commit√©s** (`views.py`, `index.html`)
* Et les fichiers **non suivis** (`get_post.docx`, `add_invoice.html`)

---

### 6Ô∏è‚É£ Cr√©ation d‚Äôune branche pour am√©liorer le template

```powershell
git checkout -b improve-add-customer
```

* Nouvelle branche cr√©√©e **√† partir de main**
* Tu peux maintenant travailler sur `add_customer.html` **sans toucher √† main**

---

### 7Ô∏è‚É£ Commit du template am√©lior√©

```powershell
git add templates/add_customer.html
git commit -m "New improved customer registration template"
```

* Tu commits **la nouvelle version du template**
* Branch `improve-add-customer` contient maintenant cette version am√©lior√©e

---

### 8Ô∏è‚É£ Push de la branche distante

```powershell
git push -u origin improve-add-customer
```

* Cr√©e la branche `improve-add-customer` sur GitHub
* `-u` lie ta branche locale √† la branche distante ‚Üí futur push/pull simplifi√©
* Git te propose m√™me de cr√©er une Pull Request sur GitHub.

---

### 9Ô∏è‚É£ Ajout des autres fichiers restants et commit

```powershell
git add .
git commit -m "initial template add_customer"
```

* Commit de tous les autres fichiers modifi√©s et non suivis :

  * notes (`cmdgit.docx`, `get_post.docx`)
  * template `add_invoice.html`
  * fichiers Django (`views.py`, `urls.py`, etc.)
* Branch `improve-add-customer` est maintenant **√† jour et compl√®te**.

---

### üîü Tentative de retour sur main

```powershell
git checkout main
```

* Git bloque car tu avais **des fichiers modifi√©s non commit√©s** (`add_customer.html`)
* ‚ö†Ô∏è Git ne veut pas √©craser tes modifications locales ‚Üí message ‚ÄúYour local changes would be overwritten‚Äù

---

### 1Ô∏è‚É£1Ô∏è‚É£ R√©solution : commit final et checkout

```powershell
git add .
git commit -m "initial template add_customer"
git checkout main
```

* Tu as **commit toutes les modifications restantes**
* Maintenant tu peux basculer sur `main` sans probl√®me
* `main` est propre et √† jour avec GitHub (`working tree clean`)

---

## üîπ R√©sum√© visuel de ce workflow

```
main  ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> (push origin/main)
        ‚îÇ    ‚îÇ
        ‚îÇ    ‚îî‚îÄ cr√©ation de branche improve-add-customer
        ‚îÇ
improve-add-customer ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> (push origin/improve-add-customer)
        ‚Üë
    commit template am√©lior√© et autres fichiers
```

* Tu as travaill√© **proprement avec des branches**
* Chaque fonctionnalit√© ou am√©lioration a sa branche
* Tu as push√© chaque branche sur GitHub
* Tu as appris √† g√©rer les **modifications non commit√©s** avant de changer de branche

---

## üîπ Les le√ßons importantes

1. **Toujours v√©rifier `git status`** avant de changer de branche
2. **Ne jamais travailler directement sur `main`**
3. **Commit ou stash** les fichiers modifi√©s pour changer de branche
4. **Cr√©er des branches par fonctionnalit√©** pour √©viter les conflits
5. **Utiliser `git push -u origin <branch>`** la premi√®re fois pour lier local ‚Üî distant


